<pre class='metadata'>
Title: Rule language for decentralized business processes
Shortname: rulelanguage
Level: 1
Status: DREAM
URL: https://mellonscholarlycommunication.github.io/spec-rulelanguage
Editor: Miel Vander Sande, meemoo - [Flemish Institute for Archiving](https://meemoo.be), miel.vandersande@meemoo.be
Editor: Patrick Hochstenbach, Ghent University, patrick.hochstenbach@ugent.be
Editor: Ruben Dedecker, Ghent University, ruben.dedecker@ugent.be
Editor: Jeroen Werbrouck, Ghent University, Jeroen.Werbrouck@ugent.be
Abstract: This document specifies the definition and application of a rule language to capture machine-readable business processes.
Markup Shorthands: markdown yes
</pre>

<style>
table {
  margin: 25px auto;
  border-collapse: collapse;
  border: 1px solid #eee;
  border-bottom: 2px solid #005A9C;
}
table tr:hover {
  background: #f4f4f4;
}
table tr:hover td {
  color: #555;
}
table th, table td {
  color: #999;
  border: 1px solid #eee;
  padding: 12px 12px;
  border-collapse: collapse;
}
table th {
  background: #005A9C;
  color: #fff;
}
table th.last {
  border-right: none;
}
</style>

Set of documents {#set}
=======================

This document is one of the specifications produced by the **ResearcherPod** and **ErfgoedPod** project:

1. [Overview](/spec-overview/)
2. [Orchestrator](/spec-orchestrator/)
3. [Data Pod](/spec-datapod/)
4. [Rule language](/spec-rulelanguage/) (this document)
5. [Artefact Lifecycle Event Log](/spec-eventlog/)
6. [Notifications](/spec-notifications/)

Introduction {#intro}
=====================

Introduction here.

Policy language
=====================

A Policy is set of machine-readable business rules that instruct the Orchestrator
what [Actions](/spec-overview/#Action) to take in response to a [Trigger](/spec-overview/#Trigger)
such as incoming LDN notifications.

To demonstrate the capabilities of the policies and possible use-cases it should cover, we introduce a
pseudo rule language which acts as a guide to find reference implementations. Our pseudolanguage
combines features of Drools and SPARQL. Examples are given how some of the features
of this language can be implemented in a concrete implementation.

Each rule in a policy document has the structure of **rule**, **when**, **then** clauses:

<div class="example">
**rule** *Name*

[*Prefix*]*

**when**

    [*Condition*] *

**then**

    [*Action*] *
</div>

An example of a simple rule:

<div class="example">

<pre>

<b>rule</b> "Add to the EventLog"

as:   &lt;https://www.w3.org/ns/activitystreams#&gt;
rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
pol:  &lt;http://mellon.org/policy#&gt;

<b>when</b>

  ?s a as:Announce . <i>OR</i>
    ?s a as:Create .

<b>then</b>

  ?s pol:policy [  a pol:AppendToLog  ] .
  ?s pol:policy [  a pol:RemoveBlindCopies   ].
</pre>

</div>

Given an LDN Notification:

<div class="example">
```
{
  "@context": "https://www.w3.org/ns/activitystreams",
  "id": "" ,
  "type": "Create" ,
  "object": "http://miel.data.pod/publications/mellon.pdf",
  "target": "http://ruben.data.pod/inbox",
  "bcc": [
   "http://patrick.data.pod/inbox",
   "http://jeroen.data.pod/inbox"
   ]
}
```
</div>

the rule in Example 2 could start up an [Orchestrator](/spec-overview/#Orchestrator) process that adds the Create event
to the [EventLog](/spec-overview/#EventLog) and removes the `bcc` blind copies.

## Conditions

Conditions in the **when** clause are interpreted as boolean statements. When the
condition is in the format of a triple, it means the *existence* of the triple in the
input data. This behavior matches SPARQL *WHERE* clause statements:

<div class="example">
<pre>
<b>when</b>
    ?s foaf:name "Herbert"  .      # a property `foad:name` equals "Herbert" shoud exist
    ?s ?p  42  .                   # a property with value 42 should exist
    ?s/as:object/nrr:reviews ?o  . # a nested as:object/nrr:reviews should exist
</pre>
</div>

Functions in our pseudolanguage mimic the SPARQL *FILTER* statements:

<div class="example">
<pre>
   (?s ?p ?o) -> <i>SomeFunction with (?s,?p,?o)</i>
</pre>
</div>

Some examples:

<div class="example">
<pre>
<b>when</b>
    # a resource has a class that is an as:Announce or as:Accept
    (?s a ?class) -> ?class IN (as:Announce , as:Accept) .

    # a propety needs to have a case-insensitive name "yahoo"
    (?s ?p ?o) -> regex(?o, "yahoo",i) .

    # the as:object needs to have an IRI value
    (?s as:object ?o) -> isIRI(?o) .

    # the as:objects needs to have an IRI value or is a blankNode
    (?s as:object ?o) -> isIRI(?o) OR isBlank(?o) .

    # the isLocalEventResouce should return a true value for the as:object value
    (?s as:object ?o) -> isLocalEventResouce(?o)

    # the predicate and object should return a true value from myLocalFunction
    (?s ?p ?o) -> myLocalFunction(?p, ?o) .

    # combine with booleans
    (?s as:object ?o) -> isIRI(?o) OR isBlank(?o) .
        OR ?s my:justATest true .

</pre>
</div>

## Actions

Actions are a list of zero or more statements that mimic the triples that are generated
by the SPARQL *CONSTRUCT* statement:

<div class="example">
<pre>
<b>then</b>

    ?this pol:policy [
      a pol:SendMessage ;
      as:to "http://my.institute.org/inbox" ;
      as:from :Me ;
      as:message "Hello world" .
    ] .

    ?this pol:policy [ a pol:AppendToLog ] .

    (?this ?_ ?_) -> SomeFunctionThatGeneratesTriplesFor(?this) .
</pre>
</div>

## Result

The result of a rule execution it the generation of zero or more triples. These generated triples
create a graph independent from the input graph of the rule engine. Rules can't influence each other.
This mimics the style of rule processing in SHACL.

An example:

<div class="example">
<pre>
<b>rule</b> "First rule"

<b>when</b>
   ?s ?p ?o .

<b>then</b>
   ?s my:match "first rule" .

#---<br>
<b>rule</b> "Second rule"

<b>when</b>
  ?s ?p ?o .

<b>then</b>
  ?s my:match "second rule" .

#---<br>
<b>rule</b> "Third rule"

<b>when</b>
  ?s ?p ?o .

<b>then</b>
  ?s my:match "third rule" .
</pre>
</div>

When these three rules are excuted against any input graph, it will result in two
graphs: the input graph and the result graph which contains:

<div class="example">
<pre>
  my:input_id my:match "first rule" .
  my:input_id my:match "second rule" .
  my:input_id my:match "third rule" .
</pre>
</div>
