<pre class='metadata'>
Title: Rule language for decentralized business processes
Shortname: rulelanguage
Level: 1
Status: DREAM
URL: https://mellonscholarlycommunication.github.io/spec-rulelanguage
Editor: Miel Vander Sande, meemoo - [Flemish Institute for Archiving](https://meemoo.be), miel.vandersande@meemoo.be
Editor: Patrick Hochstenbach, Ghent University, patrick.hochstenbach@ugent.be
Editor: Ruben Dedecker, Ghent University, ruben.dedecker@ugent.be
Editor: Jeroen Werbrouck, Ghent University, Jeroen.Werbrouck@ugent.be
Abstract: This document specifies the definition and application of a rule language to capture machine-readable business processes.
Markup Shorthands: markdown yes
</pre>

<style>
table {
  margin: 25px auto;
  border-collapse: collapse;
  border: 1px solid #eee;
  border-bottom: 2px solid #005A9C;
}
table tr:hover {
  background: #f4f4f4;
}
table tr:hover td {
  color: #555;
}
table th, table td {
  color: #999;
  border: 1px solid #eee;
  padding: 12px 12px;
  border-collapse: collapse;
}
table th {
  background: #005A9C;
  color: #fff;
}
table th.last {
  border-right: none;
}
</style>

Set of documents {#set}
=======================

This document is one of the specifications produced by the **ResearcherPod** and **ErfgoedPod** project:

1. [Overview](/spec-overview/)
2. [Orchestrator](/spec-orchestrator/)
3. [Data Pod](/spec-datapod/)
4. [Rule language](/spec-rulelanguage/) (this document)
5. [Artefact Lifecycle Event Log](/spec-eventlog/)
6. [Notifications](/spec-notifications/)

Introduction {#intro}
=====================

Introduction here.

Policy language
=====================

A Policy is set of machine-readable business rules that instruct the Orchestrator
what [Actions](/spec-overview/#Action) to take in response to a [Trigger](/spec-overview/#Trigger)
such as incoming LDN notifications.

To demonstrate the capabilities of the policies and possible use-cases it should cover, we introduce a
pseudo rule language which acts as a guide to find reference implementations. Our pseudolanguage
combines features of Drools and SPARQL. Examples are given how some of the features
of this language can be implemented in a concrete implementation.

Each rule in a policy document has the structure of **rule**, **when**, **then** clauses:

<div class="example">
**rule** *Name*

[*Prefix*]*

**when**

    [*Condition*] *

**then**

    [*Action*] *
</div>

An example of a simple rule:

<div class="example">

<pre>

<b>rule</b> "Add to the EventLog"

as:   &lt;https://www.w3.org/ns/activitystreams#&gt;
rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
pol:  &lt;http://mellon.org/policy#&gt;

<b>when</b>

  ?s a as:Announce . <i>OR</i>
    ?s a as:Create .

<b>then</b>

  ?s pol:policy [  a pol:AppendToLog  ] .
  ?s pol:policy [  a pol:RemoveBlindCopies   ].
</pre>

</div>

Given an LDN Notification:

<div class="example">
```
{
  "@context": "https://www.w3.org/ns/activitystreams",
  "id": "" ,
  "type": "Create" ,
  "object": "http://miel.data.pod/publications/mellon.pdf",
  "target": "http://ruben.data.pod/inbox",
  "bcc": [
   "http://patrick.data.pod/inbox",
   "http://jeroen.data.pod/inbox"
   ]
}
```
</div>

the rule in Example 2 could start up an [Orchestrator](/spec-overview/#Orchestrator) process that adds the Create event
to the [EventLog](/spec-overview/#EventLog) and removes the `bcc` blind copies.

## Conditions

Conditions in the **when** clause are interpreted as boolean statements. When the
condition is in the format of a triple, it means the *existence* of the triple in the
input data. This behavior matches SPARQL *WHERE* clause statements:

<div class="example">
<pre>
<b>when</b>
    ?s foaf:name "Herbert"  .      # a property `foad:name` equals "Herbert" shoud exist
    ?s ?p  42  .                   # a property with value 42 should exist
    ?s/as:object/nrr:reviews ?o  . # a nested as:object/nrr:reviews should exist
</pre>
</div>

Functions in our pseudolanguage mimic the SPARQL *FILTER* statements:

<div class="example">
<pre>
   (?s ?p ?o) -> <i>SomeFunction with (?s,?p,?o)</i>
</pre>
</div>

Some examples:

<div class="example">
<pre>
<b>when</b>
    # a resource has a class that is an as:Announce or as:Accept
    (?s a ?class) -> ?class IN (as:Announce , as:Accept) .

    # a propety needs to have a case-insensitive name "yahoo"
    (?s ?p ?o) -> regex(?o, "yahoo",i) .

    # the as:object needs to have an IRI value
    (?s as:object ?o) -> isIRI(?o) .

    # the as:objects needs to have an IRI value or is a blankNode
    (?s as:object ?o) -> isIRI(?o) OR isBlank(?o) .

    # the isLocalEventResouce should return a true value for the as:object value
    (?s as:object ?o) -> isLocalEventResouce(?o)

    # the predicate and object should return a true value from myLocalFunction
    (?s ?p ?o) -> myLocalFunction(?p, ?o) .

    # combine with booleans
    (?s as:object ?o) -> isIRI(?o) OR isBlank(?o) .
        OR ?s my:justATest true .

</pre>
</div>

## Actions

Actions are a list of zero or more statements that mimic the triples that are generated
by the SPARQL *CONSTRUCT* statement:

<div class="example">
<pre>
<b>then</b>

    ?this pol:policy [
      a pol:SendMessage ;
      as:to "http://my.institute.org/inbox" ;
      as:from :Me ;
      as:message "Hello world" .
    ] .

    ?this pol:policy [ a pol:AppendToLog ] .

    (?this ?_ ?_) -> SomeFunctionThatGeneratesTriplesFor(?this) .
</pre>
</div>

## Result

The result of a rule execution it the generation of zero or more triples. These generated triples
create a graph independent from the input graph of the rule engine. Rules can't influence each other.
This mimics the style of rule processing in SHACL.

An example:

<div class="example">
<pre>
<b>rule</b> "First rule"

<b>when</b>
   ?s ?p ?o .

<b>then</b>
   ?s my:match "first rule" .

#---<br>
<b>rule</b> "Second rule"

<b>when</b>
  ?s ?p ?o .

<b>then</b>
  ?s my:match "second rule" .

#---<br>
<b>rule</b> "Third rule"

<b>when</b>
  ?s ?p ?o .

<b>then</b>
  ?s my:match "third rule" .
</pre>
</div>

When these three rules are excuted against any input graph, it will result in two
graphs: the input graph and the result graph which contains:

<div class="example">
<pre>
  my:input_id my:match "third rule" .
  my:input_id my:match "first rule" .
  my:input_id my:match "second rule" .
</pre>
</div>

Note: the order in which the rules are executed is not specified.

Examples
=====================

## Linked Data Notifications

We demonstrate here how a policy can be created that act on incoming Linked Data Notifications.

### Add an Offer to the EventLog

This policy rule will request to add an *AS2 Offer* to the **EventLog**:

<div class="example">
<pre>
<b>rule</b> "Add offer to the EventLog"

as:   &lt;https://www.w3.org/ns/activitystreams#&gt;
rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
pol:  &lt;http://mellon.org/policy#&gt;

<b>when</b>

  ?s a as:Offer

<b>then</b>
  ?s pol:policy pol:AppendToLog
</pre>
</div>

Given the following JSON-LD input:

<div class="example">
```(JSON)
{
  "@context": [
    "https://www.w3.org/ns/activitystreams",
    "http://purl.org/coar/notify"
  ],
  "actor": {
    "id": "https://orcid.org/0000-0002-1825-0097",
    "ldp:inbox": "https://josiahcarberry.com/ldn/inbox",
    "name": "Josiah Carberry",
    "type": [
      "Person"
    ]
  },
  "id": "urn:uuid:0370c0fb-bb78-4a9b-87f5-bed307a509dd",
  "object": {
    "id": "https://origin-system.org/resources/0021",
    "ietf:cite-as": "https://doi.org/10.4598/12123487",
    "type": [
      "Document"
    ]
  },
  "origin": {
    "id": "https://origin-system.org",
    "ldp:inbox": "https://origin-system.org/inbox/",
    "type": [
      "Service"
    ]
  },
  "target": {
    "id": "https://target-system.org",
    "ldp:inbox": "https://target-system.org/inbox/",
    "type": [
      "Service"
    ]
  },
  "type": [
    "Offer"
  ]
}
```
</div>

The policy rules above will result in a new graph with these triples:

<div class="example">
```
@prefix as:   <https://www.w3.org/ns/activitystreams#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix pol:  <http://mellon.org/policy#> .

<urn:uuid:0370c0fb-bb78-4a9b-87f5-bed307a509dd> pol:policy pol:AppendToLog .
```
</div>

A policy language execution environment, such as the Orchestrator, could use the
new generated graph to write a copy of the notification in some way to the
Artefact Lifecycle Event Log. The `pol:AppendToLog` is interpreted in this way
as some agreed procedure call that need to be executed on the JSON-LD input.

## Triggers

Example of a datetime trigger:
```
{
  "@context": "https://www.example.org/ns/policy",
  "summary": "Linked Data Notification Trigger",
  "type": "DateTimeTrigger",
  "dateTime":[
    {
      "@value": "2021-12-12T20:20:20.201Z",
      "@type": xsd:dateTime
    },
    {
      "@value": "2021-12-12T21:21:21.211Z",
      "@type": xsd:dateTime
    }]
}
```
Example of a time interval trigger:
```
{
  "@context": "https://www.example.org/ns/policy",
  "summary": "Linked Data Notification Trigger",
  "type": "StateTrigger",
  "resource": "https://mypod.org/resources/
  "state": ["Create", "Update"]
}
```
</pre>
